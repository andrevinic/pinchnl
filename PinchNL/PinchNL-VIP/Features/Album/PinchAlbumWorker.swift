//
//  PinchAlbumWorker.swift
//  PinchNL
//
//  Created by Andre Nogueira on 09/03/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Moya

protocol PinchAlbumWorkerLogic {
    func requestAlbum(page: Int, completion: @escaping (Result<AlbumModels.AlbumData, Error>) -> Void)
    func requestPhotoList(requestService: PhotosModels.RequestService.Photos, completion: @escaping (Result<PhotosModels.PhotosData, Error>) -> Void)
}

class PinchAlbumWorker: PinchAlbumWorkerLogic {
    
    private let provider: PinchAPIProvider<PinchAPI>

    init(
        provider: PinchAPIProvider<PinchAPI>
    ) {
        self.provider = provider
    }
    
    func requestAlbum(page: Int, completion: @escaping (Result<AlbumModels.AlbumData, Error>) -> Void) {
        provider.request(
            .album(
                page: page
            ), completion: { [weak self] response in
                
                switch response {
                case .success(let response):
                    if let result = self?.decodeAlbumJSON(response.data) {
                        completion(
                            .success(AlbumModels.AlbumData(list:result.compactMap {
                                                            AlbumModels.AlbumData.Data(
                                                                id: $0.id,
                                                                userId: $0.userId,
                                                                title: $0.title
                                                            )}))
                        )
                    } else {
                        completion(.failure(ServiceError.invalidResponse))
                    }
                case .failure(let error):
                    completion(.failure(ServiceError.generic(message: error.localizedDescription)))
                }
            })
    }
    
    func requestPhotoList(requestService: PhotosModels.RequestService.Photos, completion: @escaping (Result<PhotosModels.PhotosData, Error>) -> Void) {
        provider.request(.photos(albumId: requestService.albumId, pagination: requestService.page), completion: { [weak self] response in
            switch response {
            case .success(let response):
                if let result = self?.decodePhotoJSON(response.data) {
                    completion(.success(PhotosModels.PhotosData(
                                            data:
                                                result.compactMap {
                                                    PhotosModels.PhotosData.Data(
                                                        title: $0.title,
                                                        url: $0.url,
                                                        thumbnailUrl: $0.thumbnailUrl
                                                    )
                                                })
                    ))
                } else {
                    completion(.failure(ServiceError.invalidResponse))
                }
            case .failure(let error):
                completion(.failure(ServiceError.generic(message: error.localizedDescription)))
            }
        })
    }
    
    private func decodeAlbumJSON(_ data: Data?) -> [AlbumResponse] {
        let decoder = JSONDecoder()
        do {
            if let jsonData = data {
                let decodedData = try decoder.decode([AlbumResponse].self, from: jsonData)
                return decodedData
            }
            return []
        } catch {
            return []
        }
    }
    
    private func decodePhotoJSON(_ data: Data?) -> [PhotoResponse] {
        let decoder = JSONDecoder()
        do {
            if let jsonData = data {
                let decodedData = try decoder.decode([PhotoResponse].self, from: jsonData)
                return decodedData
            }
            return []
        } catch {
            return []
        }
    }
}
